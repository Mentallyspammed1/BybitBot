require('dotenv').config();
const fs = require('fs');
const ccxt = require('ccxt');
const { StochasticRSI, SMA, ATR, MACD } = require('technicalindicators');
const EventEmitter = require('events');

// Neon Color Scheme
const COLORS = {
    RESET: "\x1b[0m",
    NEON_GREEN: "\x1b[38;5;46m",
    NEON_PINK: "\x1b[38;5;201m",
    NEON_CYAN: "\x1b[38;5;51m",
    NEON_YELLOW: "\x1b[38;5;226m",
    NEON_RED: "\x1b[38;5;196m"
};

// Logging Utility
const log = (level, color, message, ...args) => {
    const levels = { INFO: 1, DEBUG: 2 };
    if (levels[level] <= levels[process.env.LOG_LEVEL || 'INFO']) {
        console.log(`${color}[${new Date().toISOString()}] [${level}] [${level}] ${message}${COLORS.RESET}`, ...args);
    }
};

// Default Configuration
const DEFAULT_CONFIG = {
    exchange: { name: 'bybit', apiKey: process.env.BYBIT_API_KEY, secret: process.env.BYBIT_API_SECRET, rateLimit: 500 },
    symbol: 'BTC/USDT',
    timeframe: '1h',
    historyCandles: 300,
    analysisInterval: 60000,
    maxRetries: 5,
    retryDelay: 2000,
    riskPercentage: 0.1,
    maxPositionSizeUSDT: 100,
    stopLossMultiplier: 2,
    takeProfitMultiplier: 4,
    slTpOffsetPercentage: 0.001,
    cacheTTL: 300000,
    indicators: {
        sma: { fast: 10, slow: 30 },
        stochRsi: { rsiPeriod: 14, stochasticPeriod: 14, kPeriod: 3, dPeriod: 3 },
        atr: { period: 14 },
        macd: { fastPeriod: 12, slowPeriod: 26, signalPeriod: 9 }
    },
    thresholds: { oversold: 20, overbought: 80, minConfidence: 60 },
    volumeConfirmation: { enabled: true, lookback: 20 },
    fibonacciPivots: {
        enabled: true,
        period: '1d',
        proximityPercentage: 0.005,
        orderBookRangePercentage: 0.002,
        pivotWeight: 15,
        orderBookWeight: 10,
        levelsForBuyEntry: ['S1', 'S2'],
        levelsForSellEntry: ['R1', 'R2']
    }
};

// Global Cache
const CACHE = { markets: null, ohlcv: new Map(), orderBook: new Map() };

// Config Manager
class ConfigManager {
    constructor() { this.config = null; }
    async load(cliConfig) {
        let fileConfig = {};
        try {
            if (fs.existsSync('config.json')) {
                const configFileContent = fs.readFileSync('config.json', 'utf8');
                fileConfig = JSON.parse(configFileContent);
                log('INFO', COLORS.NEON_CYAN, 'Loaded configuration from config.json');
            } else {
                log('INFO', COLORS.NEON_YELLOW, 'config.json not found, using default configuration.');
            }
        } catch (error) {
            log('INFO', COLORS.NEON_RED, 'Error loading config.json, using default configuration:', error.message);
        }

        this.config = { ...DEFAULT_CONFIG, ...fileConfig, ...cliConfig };
        this.validateConfig();
        return this.config;
    }
    validateConfig() {
        const required = ['symbol', 'timeframe', 'exchange.apiKey', 'exchange.secret'];
        for (const key of required) {
            if (!key.split('.').reduce((obj, k) => obj?.[k], this.config)) {
                throw new Error(`Missing required config: ${key}`);
            }
        }
    }
}

// Market Data Provider
class MarketDataProvider {
    constructor(exchangeConfig, config) {
        this.exchange = new ccxt.bybit({ apiKey: exchangeConfig.apiKey, secret: exchangeConfig.secret, enableRateLimit: true, rateLimit: exchangeConfig.rateLimit });
        this.config = config;
    }

    async loadMarkets() {
        if (!CACHE.markets) {
            try {
                CACHE.markets = await this.exchange.loadMarkets();
                log('DEBUG', COLORS.NEON_CYAN, 'Markets loaded from exchange.');
            } catch (error) {
                log('INFO', COLORS.NEON_RED, 'Failed to load markets:', error.message);
                CACHE.markets = {};
            }
        }
        return CACHE.markets;
    }

    async getMinOrderSize(symbol) {
        const markets = await this.loadMarkets();
        const minSize = markets[symbol]?.limits?.amount?.min;
        if (!minSize || isNaN(minSize)) {
            log('DEBUG', COLORS.NEON_YELLOW, `No min order size for ${symbol}, defaulting to 0.01`);
            return 0.01; // Fallback
        }
        return minSize;
    }

    async getBalance() {
        try {
            const balance = await this.exchange.fetchBalance();
            return balance.total;
        } catch (error) {
            log('INFO', COLORS.NEON_RED, 'Failed to fetch balance:', error.message);
            return {};
        }
    }

    async apiHealthCheck() {
        try {
            const balance = await this.getBalance();
            log('INFO', COLORS.NEON_GREEN, 'API health check passed. Balance:', balance);
            return true;
        } catch (error) {
            log('INFO', COLORS.NEON_RED, 'API health check failed:', error.message);
            return false;
        }
    }

    async fetchOHLCV(symbol, timeframe, limit, retries = 0) {
        const cacheKey = `${symbol}-${timeframe}-${limit}`;
        const cached = CACHE.ohlcv.get(cacheKey);
        if (cached && Date.now() - cached.timestamp < this.config.cacheTTL) {
            log('DEBUG', COLORS.NEON_CYAN, `Using cached OHLCV data for ${symbol}-${timeframe}-${limit}`);
            return cached.data;
        }

        try {
            const data = await this.exchange.fetchOHLCV(symbol, timeframe, undefined, limit);
            if (data.length < limit * 0.9) throw new Error('Insufficient OHLCV data');
            const reversed = data.reverse();
            CACHE.ohlcv.set(cacheKey, { data: reversed, timestamp: Date.now() });
            log('DEBUG', COLORS.NEON_CYAN, `Fetched and cached OHLCV data for ${symbol}-${timeframe}-${limit}`);
            return reversed;
        } catch (error) {
            if (retries < this.config.maxRetries) {
                const delay = this.config.retryDelay * Math.pow(2, retries);
                log('DEBUG', COLORS.NEON_YELLOW, `Retrying OHLCV fetch (${retries + 1}/${this.config.maxRetries}) after ${delay}ms`);
                await new Promise(resolve => setTimeout(resolve, delay));
                return this.fetchOHLCV(symbol, timeframe, limit, retries + 1);
            }
            throw new Error(`Failed to fetch OHLCV: ${error.message}`);
        }
    }

    async fetchOrderBook(symbol, retries = 0) {
        const cacheKey = symbol;
        const cached = CACHE.orderBook.get(cacheKey);
        if (cached && Date.now() - cached.timestamp < this.config.cacheTTL) {
            log('DEBUG', COLORS.NEON_CYAN, `Using cached order book for ${symbol}`);
            return cached.data;
        }

        try {
            const data = await this.exchange.fetchOrderBook(symbol);
            CACHE.orderBook.set(cacheKey, { data, timestamp: Date.now() });
            log('DEBUG', COLORS.NEON_CYAN, `Fetched and cached order book for ${symbol}`);
            return data;
        } catch (error) {
            if (retries < this.config.maxRetries) {
                const delay = this.config.retryDelay * Math.pow(2, retries);
                log('DEBUG', COLORS.NEON_YELLOW, `Retrying order book fetch (${retries + 1}/${this.config.maxRetries}) after ${delay}ms`);
                await new Promise(resolve => setTimeout(resolve, delay));
                return this.fetchOrderBook(symbol, retries + 1);
            }
            throw new Error(`Failed to fetch order book: ${error.message}`);
        }
    }

    async fetchDailyOHLCV(symbol, retries = 0) {
        const timeframe = this.config.fibonacciPivots.period; // Should be '1d'
        const limit = 2;
        const cacheKey = `${symbol}-${timeframe}-${limit}`;
        const cached = CACHE.ohlcv.get(cacheKey);
        if (cached && Date.now() - cached.timestamp < this.config.cacheTTL) {
            log('DEBUG', COLORS.NEON_CYAN, `Using cached daily OHLCV data for ${symbol}`);
            return cached.data;
        }

        try {
            const data = await this.exchange.fetchOHLCV(symbol, timeframe, undefined, limit);
            if (data.length < limit * 0.9) throw new Error('Insufficient daily OHLCV data');
            const reversed = data.reverse();
            CACHE.ohlcv.set(cacheKey, { data: reversed, timestamp: Date.now() });
            log('DEBUG', COLORS.NEON_CYAN, `Fetched and cached daily OHLCV data for ${symbol}`);
            return reversed;
        } catch (error) {
            if (retries < this.config.maxRetries) {
                const delay = this.config.retryDelay * Math.pow(2, retries);
                log('DEBUG', COLORS.NEON_YELLOW, `Retrying daily OHLCV fetch (${retries + 1}/${this.config.maxRetries}) after ${delay}ms`);
                await new Promise(resolve => setTimeout(resolve, delay));
                return this.fetchDailyOHLCV(symbol, retries + 1);
            }
            throw new Error(`Failed to fetch daily OHLCV: ${error.message}`);
        }
    }
}

// Indicator Engine
class IndicatorEngine {
    constructor(config) {
        this.config = config;
        this.marketData = new MarketDataProvider(this.config.exchange, this.config);
    }

    calculateFibonacciPivots(dailyCandles) {
        if (!dailyCandles || dailyCandles.length < 1) return null;
        const previousDay = dailyCandles[1];
        if (!previousDay) return null;

        const high = previousDay[2];
        const low = previousDay[3];
        const close = previousDay[4];

        const pivotPoint = (high + low + close) / 3;
        const r1 = (2 * pivotPoint) - low;
        const s1 = (2 * pivotPoint) - high;
        const r2 = pivotPoint + (high - low);
        const s2 = pivotPoint - (high - low);
        const r3 = high + 2 * (pivotPoint - low);
        const s3 = low - 2 * (high - pivotPoint);

        return { pivot: pivotPoint, r1, r2, r3, s1, s2, s3 };
    }

    analyzeOrderBookForPivots(orderBook, pivotLevels) {
        if (!orderBook || !pivotLevels) return {};
        const rangePercentage = this.config.fibonacciPivots.orderBookRangePercentage;
        const analysisRange = (pivot) => pivot * rangePercentage;
        const depthScores = {};

        const levels = ['pivot', 's1', 's2', 'r1', 'r2'];
        levels.forEach(levelName => {
            const pivotLevel = pivotLevels[levelName];
            if (!pivotLevel) return;

            let bidDepthScore = 0;
            let askDepthScore = 0;

            if (orderBook.bids) {
                for (const [price, volume] of orderBook.bids) {
                    if (levelName.startsWith('s') || levelName === 'pivot') {
                        if (price >= pivotLevel - analysisRange(pivotLevel) && price <= pivotLevel + analysisRange(pivotLevel)) {
                            bidDepthScore += volume;
                        }
                    }
                }
            }
            if (orderBook.asks) {
                for (const [price, volume] of orderBook.asks) {
                    if (levelName.startsWith('r') || levelName === 'pivot') {
                        if (price >= pivotLevel - analysisRange(pivotLevel) && price <= pivotLevel + analysisRange(pivotLevel)) {
                            askDepthScore += volume;
                        }
                    }
                }
            }
            depthScores[levelName] = { bidDepth: bidDepthScore, askDepth: askDepthScore };
            log('DEBUG', COLORS.NEON_CYAN, `Order Book Analysis for ${levelName.toUpperCase()} at ${pivotLevel.toFixed(2)} - Bid Depth: ${bidDepthScore.toFixed(2)}, Ask Depth: ${askDepthScore.toFixed(2)}`);

        });
        return depthScores;
    }


    async calculateAll(candles, orderBook) {
        log('DEBUG', COLORS.NEON_CYAN, 'IndicatorEngine.calculateAll() called with candles:', candles ? 'Valid Candles' : 'Invalid Candles'); // Check if candles is valid
        if (!candles || candles.length < this.config.historyCandles) {
            log('WARNING', COLORS.NEON_YELLOW, 'Insufficient candles for indicator calculation. Returning null.'); // Log insufficient candles
            return null;
        }
        const closes = candles.map(c => c[4]);
        const highs = candles.map(c => c[2]);
        const lows = candles.map(c => c[3]);
        const volumes = candles.map(c => c[5]);

        // Fibonacci Pivots Calculation
        let dailyCandles;
        if (this.config.fibonacciPivots.enabled) {
            dailyCandles = await this.marketData.fetchDailyOHLCV(this.config.symbol);
            if (!dailyCandles || dailyCandles.length < 2) {
                log('WARNING', COLORS.NEON_YELLOW, 'Could not fetch sufficient daily candles for Fibonacci Pivots.');
            }
        }
        const fibonacciPivots = this.config.fibonacciPivots.enabled && dailyCandles ? this.calculateFibonacciPivots(dailyCandles) : null;
        const pivotOrderBookAnalysis = this.config.fibonacciPivots.enabled && fibonacciPivots && orderBook ? this.analyzeOrderBookForPivots(orderBook, pivotLevels) : {};


        const smaFastValues = SMA.calculate({ period: this.config.indicators.sma.fast, values: closes }); // Calculate SMA Fast
        const smaSlowValues = SMA.calculate({ period: this.config.indicators.sma.slow, values: closes }); // Calculate SMA Slow

        const sma = { // Create the sma object
            fast: smaFastValues.slice(-1)[0],
            slow: smaSlowValues.slice(-1)[0]
        };
        log('DEBUG', COLORS.NEON_CYAN, 'SMA Calculation - Fast SMA:', sma.fast, 'Slow SMA:', sma.slow); // Log SMA values


        const stochRSI = StochasticRSI.calculate({ values: closes, ...this.config.indicators.stochRsi }).slice(-1)[0];
        const atr = ATR.calculate({ high: highs, low: lows, close: closes, period: this.config.indicators.atr.period }).slice(-1)[0];
        const macd = MACD.calculate({
            values: closes,
            fastPeriod: this.config.indicators.macd.fastPeriod,
            slowPeriod: this.config.indicators.macd.slowPeriod,
            signalPeriod: this.config.indicators.macd.signalPeriod,
            SimpleMA: false
        }).slice(-1)[0];

        const indicatorData = { // Create indicatorData object
            price: closes[closes.length - 1],
            volume: volumes[volumes.length - 1],
            averageVolume: volumes.slice(-this.config.volumeConfirmation.lookback).reduce((a, b) => a + b, 0) / this.config.volumeConfirmation.lookback,
            sma: sma, // Use the created sma object
            stochRSI,
            atr,
            macd,
            fibonacciPivots,
            pivotOrderBookAnalysis
        };
        log('DEBUG', COLORS.NEON_CYAN, 'IndicatorEngine.calculateAll() returning indicatorData:', indicatorData); // Log the entire indicatorData object
        return indicatorData;
    }
}

// Signal Generator
class SignalGenerator {
    constructor(config) { this.config = config; }
    generate(indicatorData) {
        if (!indicatorData) return [];
        const { sma, stochRSI, macd, volume, averageVolume, price, fibonacciPivots, pivotOrderBookAnalysis } = indicatorData;
        const trendUp = sma.fast > sma.slow;
        const signals = [];
        let confidenceBoost = 0;
        let reasons = [];

        let volumeConfirmed = false;
        if (this.config.volumeConfirmation.enabled && volume > averageVolume) {
            volumeConfirmed = true;
            confidenceBoost += 5;
            reasons.push(`Volume Confirmed`);
            log('DEBUG', COLORS.NEON_CYAN, `Volume Confirmation: Current volume (${volume.toFixed(2)}) is above average volume (${averageVolume.toFixed(2)})`);
        } else if (this.config.volumeConfirmation.enabled) {
            log('DEBUG', COLORS.NEON_YELLOW, `Volume Confirmation: Current volume (${volume.toFixed(2)}) is below average volume (${averageVolume.toFixed(2)}) - No confirmation`);
        }

        const isMACDBullish = macd.MACD > macd.signal && macd.histogram > 0;
        const isMACDBearish = macd.MACD < macd.signal && macd.histogram < 0;

        let pivotProximityBoost = 0;
        let orderBookPivotBoost = 0;
        let pivotLevelReason = '';

        if (this.config.fibonacciPivots.enabled && fibonacciPivots) {
            const proximityPercentage = this.config.fibonacciPivots.proximityPercentage;
            const levelsForBuy = this.config.fibonacciPivots.levelsForBuyEntry;
            const levelsForSell = this.config.fibonacciPivots.levelsForSellEntry;

            const checkPivotProximity = (levels, isBuySignal) => {
                for (const levelName of levels) {
                    const pivotLevel = fibonacciPivots[levelName];
                    if (!pivotLevel) continue;
                    const proximity = Math.abs(price - pivotLevel) / price;
                    if (proximity <= proximityPercentage) {
                        let levelBoost = this.config.fibonacciPivots.pivotWeight;
                        let obBoost = 0;
                        let obAnalysis = pivotOrderBookAnalysis[levelName];

                        if (obAnalysis) {
                            if (isBuySignal && obAnalysis.bidDepth > 0) {
                                obBoost = this.config.fibonacciPivots.orderBookWeight * (obAnalysis.bidDepth / 1000);
                                orderBookPivotBoost += obBoost;
                                reasons.push(`Order Book Depth at ${levelName.toUpperCase()}`);
                                log('DEBUG', COLORS.NEON_CYAN, `Order Book boost for BUY at ${levelName.toUpperCase()}: ${obBoost.toFixed(2)} (Bid Depth: ${obAnalysis.bidDepth.toFixed(2)})`);
                            } else if (!isBuySignal && obAnalysis.askDepth > 0) {
                                obBoost = this.config.fibonacciPivots.orderBookWeight * (obAnalysis.askDepth / 1000);
                                orderBookPivotBoost += obBoost;
                                reasons.push(`Order Book Depth at ${levelName.toUpperCase()}`);
                                log('DEBUG', COLORS.NEON_CYAN, `Order Book boost for SELL at ${levelName.toUpperCase()} : ${obBoost.toFixed(2)} (Ask Depth: ${obAnalysis.askDepth.toFixed(2)})`);
                            }
                        }

                        pivotProximityBoost += levelBoost;
                        pivotLevelReason = `${levelName.toUpperCase()} Pivot Level Proximity`;
                        reasons.push(pivotLevelReason);
                        log('DEBUG', COLORS.NEON_CYAN, `Price within ${proximityPercentage * 100}% of ${levelName.toUpperCase()} Pivot, Pivot Boost: ${levelBoost}, OB Boost: ${obBoost.toFixed(2)}`);
                        return true;
                    }
                }
                return false;
            };


            let nearPivotForBuy = checkPivotProximity(levelsForBuy, true);
            let nearPivotForSell = checkPivotProximity(levelsForSell, false);

            confidenceBoost += pivotProximityBoost + orderBookPivotBoost;


        }


        if (stochRSI.k < this.config.thresholds.oversold && stochRSI.d < this.config.thresholds.oversold && trendUp) {
            let confidence = 75 + (trendUp ? 10 : 0) + confidenceBoost;
            if (isMACDBullish) {
                confidence += 10;
                reasons.push('Bullish MACD');
                log('DEBUG', COLORS.NEON_CYAN, `MACD Confirmation: Bullish MACD crossover detected`);
            } else {
                log('DEBUG', COLORS.NEON_YELLOW, `MACD Confirmation: No bullish MACD crossover`);
            }
            signals.push({ type: 'BUY', reason: ['Oversold Momentum with Uptrend & Confirmations', ...reasons].join(', '), confidence: Math.max(50, confidence), timestamp: Date.now() });
        }

        if (stochRSI.k > this.config.thresholds.overbought && stochRSI.d > this.config.thresholds.overbought && !trendUp) {
            let confidence = 75 + (!trendUp ? 10 : 0) + confidenceBoost;
            if (isMACDBearish) {
                confidence += 10;
                reasons.push('Bearish MACD');
                log('DEBUG', COLORS.NEON_CYAN, `MACD Confirmation: Bearish MACD crossover detected`);
            } else {
                log('DEBUG', COLORS.NEON_YELLOW, `MACD Confirmation: No bearish MACD crossover`);
            }
            signals.push({ type: 'SELL', reason: ['Overbought Momentum with Downtrend & Confirmations', ...reasons].join(', '), confidence: Math.max(50, confidence), timestamp: Date.now() });
        }

        return signals.filter(s => s.confidence >= this.config.thresholds.minConfidence);
    }
}


// Trading Bot
class TradingBot extends EventEmitter {
    constructor(config) {
        super();
        this.config = config;
        this.marketData = new MarketDataProvider(this.config.exchange, this.config);
        this.indicatorEngine = new IndicatorEngine(this.config);
        this.signalGenerator = new SignalGenerator(this.config);
        this.tradeContext = { currentPosition: null, entryPrice: null, stopLoss: null, takeProfit: null, positionSize: null, entryTime: null };
        this.tradeHistory = [];
    }

    async initialize() {
        try {
            if (!await this.marketData.apiHealthCheck()) throw new Error('API health check failed');
            const minSize = await this.marketData.getMinOrderSize(this.config.symbol);
            const balance = await this.marketData.getBalance();
            const usdtAvailable = balance.USDT || 0;
            this.config.positionSize = Math.max(this.config.positionSize || 0.01, minSize * 1.1);
            log('DEBUG', COLORS.NEON_CYAN, `Calculated base positionSize: ${this.config.positionSize} (minSize: ${minSize})`);

            if (this.config.maxPositionSizeUSDT > 0 && usdtAvailable > 0) {
                const maxPositionSizeBasedOnUSDT = this.config.maxPositionSizeUSDT / (await this.marketData.fetchOrderBook(this.config.symbol)).bids[0][0];
                this.config.positionSize = Math.min(this.config.positionSize, maxPositionSizeBasedOnUSDT);
                log('DEBUG', COLORS.NEON_CYAN, `Position size adjusted based on maxPositionSizeUSDT (${this.config.maxPositionSizeUSDT} USDT): ${this.config.positionSize}`);
            }


            if (usdtAvailable < this.config.positionSize * 0.1) {
                log('INFO', COLORS.NEON_YELLOW, `Low USDT balance (${usdtAvailable}), position size might be further adjusted during order placement.`);
            }
            log('INFO', COLORS.NEON_GREEN, `Bot initialized for ${this.config.symbol} on Bybit. Initial positionSize: ${this.config.positionSize}`);
            this.emit('initialized');
        } catch (error) {
            log('INFO', COLORS.NEON_RED, 'Initialization failed:', error.message);
            throw error;
        }
    }

    async start() {
        try {
            log('INFO', COLORS.NEON_CYAN, `Trading bot started for ${this.config.symbol} on ${this.config.timeframe}`);
            await this.analysisCycle();
            this.interval = setInterval(() => this.analysisCycle(), this.config.analysisInterval);
        } catch (error) {
            log('INFO', COLORS.NEON_RED, 'Start failed:', error.message);
        }
    }

    async analysisCycle() {
        try {
            const candles = await this.marketData.fetchOHLCV(this.config.symbol, this.config.timeframe, this.config.historyCandles);
            const orderBook = await this.marketData.fetchOrderBook(this.config.symbol);
            log('DEBUG', COLORS.NEON_CYAN, 'TradingBot.analysisCycle() - Fetched candles:', candles ? 'Candles Fetched' : 'Candles Fetch Failed'); // Log candle fetch status
            const indicators = this.indicatorEngine.calculateAll(candles, orderBook);
            log('DEBUG', COLORS.NEON_CYAN, 'TradingBot.analysisCycle() - IndicatorEngine.calculateAll() result:', indicators ? 'Indicators Calculated' : 'Indicators Calculation Failed (null)'); // Log indicator calculation result

            if (!indicators) return; // Early return if indicators are null (important!)


            if (this.tradeContext.currentPosition) {
                const { price } = indicators;
                if (price <= this.tradeContext.stopLoss) {
                    await this.closePosition('Stop Loss Triggered');
                } else if (price >= this.tradeContext.takeProfit) {
                    await this.closePosition('Take Profit Triggered');
                }
            }

            const signals = this.signalGenerator.generate(indicators);
            this.emit('signals', signals);
            await this.executeStrategy(signals, indicators, orderBook);
        } catch (error) {
            log('INFO', COLORS.NEON_RED, 'Analysis error:', error.message);
        }
    }

    async executeStrategy(signals, indicators, orderBook) {
        if (!signals.length) return;
        const primarySignal = signals[0];
        log('INFO', COLORS.NEON_PINK, `Primary Signal: ${primarySignal.type} (${primarySignal.reason}, Confidence: ${primarySignal.confidence.toFixed(2)}%)`);

        const balance = await this.marketData.getBalance();
        const usdtAvailable = balance.USDT || 0;
        const entryPrice = orderBook.bids[0]?.[0] || indicators.price;
        let positionSize = Math.min(this.config.positionSize, (usdtAvailable * this.config.riskPercentage) / entryPrice);

        if (primarySignal.type === 'BUY' && !this.tradeContext.currentPosition) {
            const minSize = await this.marketData.getMinOrderSize(this.config.symbol);
            positionSize = Math.max(positionSize, minSize * 1.1);
            const cost = entryPrice * positionSize;
            if (cost > usdtAvailable) {
                positionSize = (usdtAvailable * 0.9) / entryPrice;
                log('DEBUG', COLORS.NEON_YELLOW, `Adjusted positionSize to ${positionSize} due to insufficient balance (${usdtAvailable} USDT), new size: ${positionSize}`);
            }
            if (positionSize * entryPrice > this.config.maxPositionSizeUSDT && this.config.maxPositionSizeUSDT > 0) {
                positionSize = this.config.maxPositionSizeUSDT / entryPrice;
                log('DEBUG', COLORS.NEON_YELLOW, `Position size adjusted to maxPositionSizeUSDT limit (${this.config.maxPositionSizeUSDT} USDT), new size: ${positionSize}`);
            }
            await this.placeOrder('buy', positionSize, entryPrice, indicators.atr, primarySignal.reason);
        } else if (primarySignal.type === 'SELL' && this.tradeContext.currentPosition) {
            await this.closePosition('Sell Signal Triggered');
        } else {
            log('DEBUG', COLORS.NEON_CYAN, `No action taken. Signal: ${primarySignal.type}, Current Position: ${this.tradeContext.currentPosition || 'None'}`);
        }
    }

    calculateStopLossTakeProfit(side, entryPrice, atr) {
        let stopLossPrice, takeProfitPrice;
        const atrValue = atr || 0;
        const offset = entryPrice * this.config.slTpOffsetPercentage;

        if (side === 'buy') {
            stopLossPrice = entryPrice - (atrValue * this.config.stopLossMultiplier) - offset;
            takeProfitPrice = entryPrice + (atrValue * this.config.takeProfitMultiplier) + offset;
        } else {
            stopLossPrice = entryPrice + (atrValue * this.config.stopLossMultiplier) - offset;
            takeProfitPrice = entryPrice - (atrValue * this.config.takeProfitMultiplier) - offset;
        }
        return { stopLoss: stopLossPrice, takeProfit: takeProfitPrice };
    }


    async placeOrder(side, quantity, price, atr, signalReason, retries = 0) {
        if (quantity <= 0) {
            log('WARNING', COLORS.NEON_YELLOW, `Skipping order placement for ${side.toUpperCase()} due to zero or negative quantity: ${quantity}`);
            return null;
        }
        try {
            const { stopLoss, takeProfit } = this.calculateStopLossTakeProfit(side, price, atr);
            const roundedStopLoss = parseFloat(stopLoss.toFixed(5));
            const roundedTakeProfit = parseFloat(takeProfit.toFixed(5));

            log('INFO', COLORS.NEON_GREEN, `Placing ${side.toUpperCase()} order for ${quantity.toFixed(4)} ${this.config.symbol} at ${price.toFixed(2)}, SL: ${roundedStopLoss}, TP: ${roundedTakeProfit}`);
            const order = await this.marketData.exchange.createOrder(this.config.symbol, 'limit', side, quantity, price);
            log('INFO', COLORS.NEON_GREEN, `Order placed successfully: ${order.id}, Side: ${side.toUpperCase()}, Quantity: ${quantity.toFixed(4)}, Price: ${price.toFixed(2)}, SL: ${roundedStopLoss}, TP: ${roundedTakeProfit}`);

            if (side === 'buy') {
                this.tradeContext = {
                    currentPosition: 'BUY',
                    entryPrice: price,
                    stopLoss: roundedStopLoss,
                    takeProfit: roundedTakeProfit,
                    positionSize: quantity,
                    entryTime: Date.now()
                };
                log('DEBUG', COLORS.NEON_CYAN, `Position opened - Entry Price: ${price.toFixed(2)}, SL: ${roundedStopLoss}, TP: ${roundedTakeProfit}`);
                this.tradeHistory.push({
                    entryTime: this.tradeContext.entryTime,
                    entryPrice: this.tradeContext.entryPrice,
                    positionSize: this.tradeContext.positionSize,
                    side: 'BUY',
                    symbol: this.config.symbol,
                    stopLoss: this.tradeContext.stopLoss,
                    takeProfit: this.tradeContext.takeProfit,
                    status: 'OPEN',
                    entryReason: signalReason
                });
            }
            return order;
        } catch (error) {
            log('INFO', COLORS.NEON_RED, `Order placement failed (${side.toUpperCase()}): ${error.message}`);
            if (error.message.includes('170136') && retries < this.config.maxRetries) {
                const minSize = await this.marketData.getMinOrderSize(this.config.symbol);
                quantity = Math.max(quantity, minSize * 1.1);
                const delay = this.config.retryDelay * Math.pow(2, retries);
                log('DEBUG', COLORS.NEON_YELLOW, `Retrying order placement with adjusted size ${quantity.toFixed(4)} after ${delay}ms (${retries + 1}/${this.config.maxRetries})`);
                await new Promise(resolve => setTimeout(resolve, delay));
                return this.placeOrder(side, quantity, price, atr, signalReason, retries + 1);
            }
            throw error;
        }
    }

    async closePosition(reason) {
        if (!this.tradeContext.currentPosition) return;
        try {
            log('INFO', COLORS.NEON_GREEN, `Closing ${this.tradeContext.currentPosition} position due to: ${reason}`);
            const sellOrder = await this.marketData.exchange.createOrder(this.config.symbol, 'market', 'sell', this.tradeContext.positionSize);
            const exitPrice = sellOrder.averageFillPrice || sellOrder.price || 0;
            log('INFO', COLORS.NEON_GREEN, `Position closed (${reason}). Order ID: ${sellOrder.id}, Exit Price: ${exitPrice.toFixed(2) || 'Market Price'}`);

            const trade = this.tradeHistory.find(t => t.status === 'OPEN' && t.entryTime === this.tradeContext.entryTime);
            if (trade) {
                trade.status = 'CLOSED';
                trade.exitTime = Date.now();
                trade.exitPrice = exitPrice;
                trade.exitReason = reason;
                const profit = (trade.side === 'BUY' ? (exitPrice - trade.entryPrice) : (trade.entryPrice - exitPrice)) * trade.positionSize;
                trade.profit = profit;
                log('INFO', COLORS.NEON_GREEN, `Trade Profit: ${profit.toFixed(2)} USDT. Reason: ${reason}`);
            } else {
                log('WARNING', COLORS.NEON_YELLOW, 'Could not find corresponding open trade in history to update.');
            }

            this.tradeContext = { currentPosition: null, entryPrice: null, stopLoss: null, takeProfit: null, positionSize: null, entryTime: null };
        } catch (error) {
            log('INFO', COLORS.NEON_RED, `Position close failed (${reason}): ${error.message}`);
        }
    }

    stop() {
        clearInterval(this.interval);
        log('INFO', COLORS.NEON_RED, 'Bot stopped.');
        if (this.tradeContext.currentPosition) {
            log('WARNING', COLORS.NEON_YELLOW, 'Bot stopped with an open position. Consider manually closing it!');
        }
        log('INFO', COLORS.NEON_CYAN, '=== Trade History & Performance ===');
        if (this.tradeHistory.length === 0) {
            log('INFO', COLORS.NEON_CYAN, 'No trades executed.');
        } else {
            let wins = 0;
            let losses = 0;
            this.tradeHistory.forEach(trade => {
                log('INFO', COLORS.NEON_CYAN, `Symbol: ${trade.symbol}, Side: ${trade.side}, Entry: ${trade.entryPrice.toFixed(2)}, Exit: ${trade.exitPrice ? trade.exitPrice.toFixed(2) : 'N/A'}, Profit: ${trade.profit ? trade.profit.toFixed(2) : 'N/A'}, Status: ${trade.status}, Entry Reason: ${trade.entryReason}, Exit Reason: ${trade.exitReason}`);
                if (trade.profit > 0) wins++;
                else if (trade.profit < 0) losses++;
            });
            const totalProfit = this.tradeHistory.reduce((sum, trade) => sum + (trade.profit || 0), 0);
            const winRate = this.tradeHistory.length > 0 ? (wins / this.tradeHistory.length) * 100 : 0;
            const lossRate = this.tradeHistory.length > 0 ? (losses / this.tradeHistory.length) * 100 : 0;


            log('INFO', COLORS.NEON_CYAN, `--- Performance Summary ---`);
            log('INFO', COLORS.NEON_CYAN, `Total Trades: ${this.tradeHistory.length}`);
            log('INFO', COLORS.NEON_CYAN, `Wins: ${wins}, Losses: ${losses}`);
            log('INFO', COLORS.NEON_CYAN, `Win Rate: ${winRate.toFixed(2)}%, Loss Rate: ${lossRate.toFixed(2)}%`);
            log('INFO', COLORS.NEON_CYAN, `Total Profit/Loss: ${totalProfit.toFixed(2)} USDT`);

            // Simple Drawdown Calculation
            let maxBalance = 0;
            let currentBalance = 0;
            let maxDrawdown = 0;
            this.tradeHistory.forEach(trade => {
                currentBalance += trade.profit || 0;
                maxBalance = Math.max(maxBalance, currentBalance);
                const drawdown = maxBalance - currentBalance;
                maxDrawdown = Math.max(maxDrawdown, drawdown);
            });
            log('INFO', COLORS.NEON_CYAN, `Max Drawdown: ${maxDrawdown.toFixed(2)} USDT (Approximate)`);

        }
    }
}

// Prompt Helper
async function promptForInput(promptText, defaultValue, validator) {
    const rl = require('readline').createInterface({ input: process.stdin, output: process.stdout });
    while (true) {
        const answer = await new Promise(resolve => rl.question(promptText, resolve));
        if (!answer.trim()) {
            rl.close();
            return defaultValue;
        } else if (validator(answer)) {
            rl.close();
            return answer;
        }
        log('INFO', COLORS.NEON_YELLOW, `Invalid input: ${answer}. Please try again.`);
    }
}

// Main Execution
async function runBot() {
    const tempExchange = new ccxt.bybit();

    // --- .env File Loading Verification ---
    log('DEBUG', COLORS.NEON_CYAN, 'Attempting to load configuration from .env file...'); // Log attempt

    require('dotenv').config(); // Load .env file

    // Check if API keys are loaded from .env (or environment variables)
    const apiKeyFromEnv = process.env.BYBIT_API_KEY;
    const apiSecretFromEnv = process.env.BYBIT_API_SECRET;

    if (!apiKeyFromEnv || !apiSecretFromEnv) {
        console.error(COLORS.NEON_RED, "Error: API keys not found in environment variables (or .env file).", COLORS.RESET);
        console.error(COLORS.NEON_RED, "Please ensure you have set BYBIT_API_KEY and BYBIT_API_SECRET as environment variables or in a .env file", COLORS.RESET);
        console.error(COLORS.NEON_RED, "in the same directory as whaleone.js.", COLORS.RESET);
        console.error(COLORS.NEON_RED, "Bot will exit now.", COLORS.RESET);
        process.exit(1);
        return;
    }

    log('DEBUG', COLORS.NEON_CYAN, '.env file configuration loaded successfully (if present).', COLORS.RESET); // Log success
    log('DEBUG', COLORS.NEON_CYAN, 'API Key (first 4 chars):', apiKeyFromEnv.substring(0, 4) + '****', COLORS.RESET); // Log masked API key
    log('DEBUG', COLORS.NEON_CYAN, 'API Secret (first 4 chars):', apiSecretFromEnv.substring(0, 4) + '****', COLORS.RESET); // Log masked API secret
    // --- End .env File Loading Verification ---


    try {
        await tempExchange.loadMarkets();
        console.log(COLORS.NEON_CYAN, "Markets loaded successfully from Bybit.", COLORS.RESET);

        if (!tempExchange.timeframes) {
            console.error(COLORS.NEON_RED, "Error: tempExchange.timeframes is undefined after loadMarkets().", COLORS.RESET);
            console.error(COLORS.NEON_RED, "Please check your network connection and Bybit API setup. Ensure your API keys are correct and have the necessary permissions.", COLORS.RESET);
            process.exit(1);
            return;
        }
        if (typeof tempExchange.timeframes !== 'object') {
            console.error(COLORS.NEON_RED, "Error: tempExchange.timeframes is not an object. It is of type:", typeof tempExchange.timeframes, COLORS.RESET);
            console.error(COLORS.NEON_RED, "This is unexpected. Please check your ccxt installation. Try reinstalling 'ccxt' using 'npm install ccxt' or 'yarn add ccxt'.", COLORS.RESET);
            process.exit(1);
            return;
        }

        const timeframes = Object.keys(tempExchange.timeframes);
        console.log(COLORS.NEON_CYAN, "Available timeframes:", timeframes, COLORS.RESET);

        if (!Array.isArray(timeframes)) {
            console.error(COLORS.NEON_RED, "Error: timeframes is not an array after Object.keys(). It is of type:", typeof timeframes, COLORS.RESET);
            console.error(COLORS.NEON_RED, "This is highly unexpected. Please check your JavaScript environment and ccxt installation. Ensure Node.js is correctly installed and 'ccxt' is properly installed and up-to-date.", COLORS.RESET);
            process.exit(1);
            return;
        }

        const symbols = tempExchange.symbols;
        console.log(COLORS.NEON_CYAN, "Available symbols (first 10):", symbols.slice(0, 10), COLORS.RESET);

        const symbol = await promptForInput(
            'Enter symbol (e.g., BTC/USDT, ETH/USDT, default: BTC/USDT): ',
            'BTC/USDT',
            input => symbols.includes(input)
        );
        const timeframe = await promptForInput(
            'Enter timeframe (e.g., 1m, 15m, 1h, default: 1h): ',
            '1h',
            input => {
                if (!timeframes.includes) {
                    console.error(COLORS.NEON_RED, "Critical Error: timeframes.includes is still not a function! Validation cannot proceed.", COLORS.RESET);
                    return false;
                }
                return timeframes.includes(input);
            }
        );

        const cliConfig = { symbol, timeframe };
        const configManager = new ConfigManager();
        await configManager.load(cliConfig);

        const bot = new TradingBot(configManager.config);
        bot.on('initialized', () => bot.start());
        bot.on('signals', signals => {
            if (signals.length) {
                log('INFO', COLORS.NEON_CYAN, '\n=== Signals ===');
                signals.forEach(s => log('INFO', COLORS.NEON_GREEN, `${s.type} - ${s.reason} (${s.confidence.toFixed(2)}%)`));
            }
        });

        await bot.initialize();

    } catch (error) {
        console.error(COLORS.NEON_RED, 'Startup error in runBot function:', error.message, COLORS.RESET);
        console.error(COLORS.NEON_RED, 'Full error object:', error, COLORS.RESET);
        process.exit(1);
    }

    process.on('SIGINT', async () => {
        log('INFO', COLORS.NEON_YELLOW, 'Shutting down bot...');
        await bot.closePosition('Shutdown signal (SIGINT)');
        bot.stop();
        process.exit(0);
    });
}

runBot().catch(error => {
    console.error(COLORS.NEON_RED, 'Top-level startup error:', error.message, COLORS.RESET);
    process.exit(1);
});


// Start the bot
runBot();
