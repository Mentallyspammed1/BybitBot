import ccxt;import time;exchange = ccxt.binance();symbol = 'APT/USDT';initial_balance = None;in_position = None;entry_price = None;profit_percentage_target = 0.01;def check_signals(orderbook): global initial_balance, in_position, entry_price; bid = orderbook['bids'][0][0] if orderbook['bids'] else None; ask = orderbook['asks'][0][0] if orderbook['asks'] else None; if bid and ask: spread = ask - bid; if spread > 0.02 and in_position != 'short': print('Potential Short Signal'); if in_position == 'long': if bid < entry_price * (1 - profit_percentage_target): print('Close Long Position for Profit'); in_position = None; elif bid > entry_price: print('Long Position still in profit'); else: print('Long Position in loss'); in_position = 'short'; entry_price = ask; initial_balance = 1000 # Hypothetical balance for profit calculation print(f'Opened Short Position at {entry_price}'); elif spread < 0.01 and in_position != 'long': print('Potential Long Signal'); if in_position == 'short': if ask > entry_price * (1 + profit_percentage_target): print('Close Short Position for Profit'); in_position = None; elif ask < entry_price: print('Short Position still in profit'); else: print('Short Position in loss'); in_position = 'long'; entry_price = bid; initial_balance = 1000 # Hypothetical balance for profit calculation print(f'Opened Long Position at {entry_price}'); else: print('Neutral Signal'); else: print('Insufficient orderbook data');def main(): global in_position; in_position = None; while True: try: orderbook = exchange.fetch_order_book(symbol); check_signals(orderbook); time.sleep(10); except Exception as e: print(f'Error: {e}'); time.sleep(10);if __name__ == '__main__': main()
